:imagesdir: ./images
<<<

== 5.Les clés de la durabilité de logiciels (Matrice) /// rest à faire///

Après avoir recueilli les critères, j'ai dû les organiser en une matrice. Cette dernière illustre la durabilité du logiciel en lui donnant une note de 1 à 5.

Ces notes : 

* *1* -> 0 - 20% -> le logiciel est *Mauvais*. 
* *2* -> 20 - 40% -> le logiciel est *Moyen*.
* *3* -> 40 - 60% -> le logiciel est *Bien*.
* *4* -> 60 - 80% -> le logiciel est *Très bien*. 
* *5* -> 80 - 100% -> le logiciel est *Excellent*.

Pour réaliser cette matrice, je l'ai divisée en deux parties.  La première, à gauche, contient les critères utilisés. Ceux-ci sont classés en deux catégories : *Conception* et *Développement*, en ajoutant leur type et leur poids.
La deuxième, à droite, à remplir par *le client*,  ???*le chef de projet*.



Voici les critères retenus pour la matrice : 

* Mise à jour de sécurité jointes aux mises à jour fonctionnelles : 

Ce critère signifie que l'éditeur de logiciels doit être transparent pour séparer les mises à jour de sécurité des mises à jour fonctionnelles en annonçant au client le type de mise à jour auquel chaque mise à jour est destinée (mise à jour corrective, mise à jour évolutive). Car les mises à jour correctives sont indispensables et souvent légères. Au contraire, les mises à jour évolutives ne sont pas indispensables et lourdes.

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. En outre, ce critère avait le pourcentage de 52,2% dans le questionnaire.

* Lazy loading : 

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. ?

*Lazy loading* :  est un modèle de conception couramment utilisé en programmation informatique pour différer l'initialisation d'un objet jusqu'au moment où il est nécessaire. Il peut contribuer à l'efficacité du fonctionnement du programme s'il est utilisé correctement et convenablement. Il est donc idéal dans les cas d'utilisation où le contenu du réseau est accessible et où les temps d'initialisation doivent être réduits au minimum, comme dans le cas des pages web. L'inverse de lazy loading is eager loading. <<R>>

* Programmation Objet vs Programmation Fonctionnelle : 

Ce critère a été défini par l'interview <<Annexe?>>. 

*Programmation Objet*: est un paradigme de programmation informatique. Il consiste en la définition et l'interaction de briques logicielles appelées objets ; un objet représente un concept, une idée ou toute entité du monde physique, comme une voiture, une personne ou encore une page d'un livre. Il possède une structure interne et un comportement, et il sait interagir avec ses pairs. Il s'agit donc de représenter ces objets et leurs relations ; l'interaction entre les objets via leurs relations permet de concevoir et réaliser les fonctionnalités attendues, de mieux résoudre le ou les problèmes. Dès lors, l'étape de modélisation revêt une importance majeure et nécessaire pour la POO. C'est elle qui permet de transcrire les éléments du réel sous forme virtuelle. <<S>>

*Programmation Fonctionnelle* :  est un paradigme de programmation de type déclaratif qui considère le calcul en tant qu'évaluation de fonctions mathématiques. <<T>>

* Cloud Synchronisation : 

Le cloud se définit par la mise en disposition des ressources informatiques utilisables depuis toutes les types terminales via l'internet. 

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j’ai menée à la question *Est-ce que le cloud est green ?*


Comme mentionné dans l'état de l'art, (page à ajouter), les terminaux que nous utilisons génèrent des impacts environnementaux et sociaux très importants, non seulement en termes de fabrication, mais aussi en termes d'utilisation et de fin de vie. Sachant que les entreprises utilisent le cloud pour stocker leurs données et permettre à leurs employeurs de travailler à distance.  Cela nécessite donc une forte augmentation des besoins en matériel pour sauvegarder les données, généralement accompagnée d'attentes élevées en termes de sécurité, ce qui se traduit par une infrastructure physique surdimensionnée. De plus, les déploiements de sécurité des données, l'illusion d'une capacité infinie, encourage l'informatique débridée *l'obésité*.

Toutefois, il existe sans aucun doute une utilisation éclairée du cloud !

Il existe sur l'internet une vidéo réalisée par l'Alliance Green IT, illustre que le Cloud n’est pas la panacée à la problématique environnementale du stockage et l’utilisation de données numériques. Disponible sur : https://www.dailymotion.com/video/x2hntue

* Fichier VS Base De Données : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Stockage Réseau VS Local : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Appel Réseau : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Compilé VS Interpreté : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Travaille en arrière paln : 

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. ?

* Lancer automatiquement au démarrage par défaut :

Ce critère a été défini par l'interview <<Annexe?>>. 

* Mode Nuit / Jour : 

Ce critère a été défini par le questionnaire.

* Optimiser l'utilisation du CPU (Usage intensif du CPU) : 

Ce critère a été défini par le questionnaire.

* Optimiser l'algorithmie ( Action humaine ) : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Optimiser les instructions de code ( Action compilateur) : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Taux I/O RAM VS DD : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Optimiser l'utilisation du Mémoire ( Usage intensif du Mémoire) : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Binaire qui prend de l'espace : -> site greenit

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. ?

* Pourcentage d'utilisation d'Open Source : 

Ce critère a été défini par le questionnaire.

* Bugs : 

Ce critère a été défini par le questionnaire.

* La mauvaise lisibilité du code pour mieux l'appréhendre ( Évolution correction) : 

Ce critère a été défini par le questionnaire.


.Matrice 
[caption="Figure 3: "]
image::Matrice.jpg[Matrice]


Impact fort sur l'utilisation de la batterie;TRILEAN;Utilisation; -> travail futur

Empriente résiduelle;POURCENTAGE;Intégration;  -> travail futur
