:imagesdir: ./images

<<<

[#Matrice]
== 6.Les clés de la durabilité de logiciels (Matrice) /// rest à faire, vérifier le numéro d'annexe///

Après avoir recueilli les critères, j'ai dû les organiser en une matrice. Cette dernière illustre la durabilité du logiciel en lui donnant une note de 1 à 5.

Ces notes : 

* *1* -> 0 - 20% -> le logiciel est *Mauvais*. 
* *2* -> 20 - 40% -> le logiciel est *Moyen*.
* *3* -> 40 - 60% -> le logiciel est *Bien*.
* *4* -> 60 - 80% -> le logiciel est *Très bien*. 
* *5* -> 80 - 100% -> le logiciel est *Excellent*.

Pour réaliser cette matrice, je l'ai divisée en deux parties. La première, à gauche, contient les critères utilisés. Ceux-ci sont classés en deux catégories : *Conception* et *Développement*, en ajoutant leurs type et leurs poids.

Pour le type de critères, j'ai choisi trois types : 

* *Trilean* (True, False, Null).
* *Boolean* (True, False).
* *Pourcentage*. 

Pour le poids, j'ai donné la valeur 100 à ces deux catégories. Ensuite, pour chaque critère de ces catégories, j'ai donné une valeur sur 100 selon l'importance du critère établi sur la base des interviews et du questionnaire.

La deuxième, à droite, est à remplir par *le chef de projet*. Le chef de projet évalue le logiciel en fonction de la mesure dans laquelle le logiciel répond à ces critères. La plus mauvaise valeur est placée dans l'intervalle (0% - 20%), et la meilleure valeur est placée dans l'intervalle (80% - 100%).

=== 6.1.Les critères retenus pour la matrice  

* *Séparation entre les mises à jour de sécurité et les mises à jour fonctionnelles :* 

Ce critère signifie que l'éditeur de logiciels doit être transparent pour séparer les mises à jour de sécurité des mises à jour fonctionnelles en annonçant au client le type de mise à jour auquel chaque mise à jour est destinée (mise à jour corrective, mise à jour évolutive). Car les mises à jour correctives sont indispensables et souvent légères. Au contraire, les mises à jour évolutives ne sont pas indispensables et lourdes. Donc, l'utilisateur a le choix d'accepter les mises à jours de sécurité et d'accepter ou réfuser les mises à jour fonctionnelles.

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. En outre, ce critère avait le pourcentage de 52,2% dans le questionnaire.

* *Lazy loading :*

Ce critère signifie que le logiciel doit télécharger ses dépendances lorsqu'il en a besoin. Cela signifie que le logiciel ne consomme de l'énergie et de l'appel réseau concernant ces dépendances que lorsqu'il est nécessaire, ce qui reflète l'évaluation du Green de ce critère.

Ce critère est parmi ceux ajoutés selon ma propre expérience en ce qui concerne le sujet de *Durabilité des logiciels*.

*Lazy loading* : est un modèle de conception généralement utilisé en programmation informatique. Son objectif est d'initialiser un objet uniquement quand cet objet devient nécessaire. De cette manière, Lazy Loading participe effectivement à l'efficacité du fonctionnement du logiciel s'il est utilisé d'une façon correcte et adéquate. Cela rend Lazy Loading une propriété idéale dans les cas d’utilisation où le contenu du réseau est accessible et où le temps d’initialisation doit être réduit au minimum, comme dans le cas des pages web. L’inverse de Lazy Loading est Eager Loading. <<R>>

* *Programmation Orienté Objet vs Programmation Fonctionnelle :*

Ce critère a été défini par l'interview <<Annexe?>>. Selon l'avis des experts, la programmation orientée objet est plus légère et rapide que la programmation fonctionnelle. Puisqu'elle ne utilise que les objets nécessaires à réaliser les fonctionnalitiés attendues. Ce qui limite l'utilisation des ressources matériels au minimum. Par conséquent, la programmation orientée objet est plus préservante de l'environnement.

*Programmation orientée Objet*: est un modèle de programmation informatique étant formé de la définition et l'interaction de blocs logiciels appelés objets. Ces derniers représentent plusieurs variables pouvant aller des concepts et des idées à toute entité du monde physique, comme un ordinateur, une maison, etc. Ces objets possèdent une structure interne et un comportement, et savent interagir avec leurs pairs. L'objectif de la Programmation Orientée Objet est de représenter ces objets et leurs relations pour mieux résoudre le problème ; cela peut être effecteur en concevant et en réalisant les fonctionnalités attendues par l'interaction entre les objets via leurs relations. De ce qui précède, l'étape de modélisation évoque une grande importance nécessaire pour la Programmation Orientée Objet, puisque la transcription des réels éléments sous forme virtuelle se passe durant cette étape. <<S>>

*Programmation Fonctionnelle* :  est un modèle de programmation de type déclaratif et se concentre sur la notion des fonctions. Le calcul est considéré comme une évaluation des fonctions mathématiques dans ce modèle, ce qui veut dire que tous les éléments sont définies comme des fonctions et le code s'exécute par des appels successifs des fonctions . <<T>>

* *Cloud Synchronisation :* 

Le cloud se définit par la mise en disposition des ressources informatiques utilisables depuis toutes les types terminales via l'internet. 

D'après ma propre expérience, ce critère a été ajouté suite à la pose de la question : *Est-ce le cloud est green?*


Comme mentionné dans l'état de l'art, (page à ajouter), les terminaux que nous utilisons génèrent des impacts environnementaux et sociaux très importants, non seulement en termes de fabrication, mais aussi en termes d'utilisation et de fin de vie. Sachant que les entreprises utilisent le cloud pour stocker leurs données et permettre à leurs employeurs de travailler à distance.  Cela nécessite donc une forte augmentation des besoins en matériel pour sauvegarder les données, généralement accompagnée d'attentes élevées en termes de sécurité, ce qui se traduit par une infrastructure physique surdimensionnée. De plus, les déploiements de sécurité des données, l'illusion d'une capacité infinie, encourage l'informatique débridée *obèse*.

Toutefois, il existe sans aucun doute une utilisation éclairée du cloud !

Il existe sur l'internet une vidéo réalisée par l'Alliance Green IT, illustre que le Cloud n’est pas la panacée à la problématique environnementale du stockage et l’utilisation de données numériques. Disponible sur : https://www.dailymotion.com/video/x2hntue

* *Fichier VS Base De Données :*

Ce critère a été défini par l'interview <<Annexe?>>. 

La structure logicielle du fichier est simple est sobre. Par contre, la structure logicielle de la base de donnée est plus compliquée et costaude. Ainsi, et afin de moins utiliser de l'énergie au but de préserver l'environnement, la structure logicielle de la base de donnée doit être simple et organisée de manière facilitante les requêtes.


* *Stockage Réseau VS Local :*

Ce critère a été défini par l'interview <<Annexe?>>.

Ce critère désigne quel type de stockage est utilisé. 
Le stockage en réseau nécessite un réseau pour stocker les données dans les centres de données. Le fonctionnement de ces derniers nécessite de l'énergie et du refroidissement constants, ce qui augmente l'impact environnemental négatif. Le stockage local stocke les données directement en mémoire, et donc il n'utilise qu'une part de l'énergie nécessaire au fonctionnement de l'appareil informatique. Ce dernier peut être éteint ce qui diminue l'impact environnemental négatif. 

* *Appel Réseau :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère indique le nombre de demandes que le logiciel a présenté. Plus le nombre de demandes est élevé, plus l'impact du logiciel sur l'environnement à travers le matériel et le réseau est important.

* *Compilé VS Interprété :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère indique le type utilisé du langage de programmation : Compilé ou Interprété.

À partir de la définition de chaque langage, le langage compilé est plus rapide et traduit le code directement en langage machine. Alors que le langage interprété a besoin d'un interprète, ce qui complique la procédure et consomme plus d'énergie. De ce qui précède, le langage compilé est plus favorable en faveur des exigences environnementales.

* *Travail en arrière paln :* 

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*.

Ce critère indique si le logiciel contient des composants qui fonctionnent en arrière paln, c'est-à-dire si le logiciel fonctionne lorsqu'il n'est pas utilisé par l'utilisateur. En effet, un tel logiciel consomme de l'énergie, même s'il est dans un cas inactif. Ce qui annonce que ce critère rend le logiciel moins Green.

* *Lancer automatiquement au démarrage par défaut :*

Ce critère a été défini par le questionnaire avec un pourcentage de 39.1%.

Ce critère signifie que les dépendances de logiciel fonctionnent directement par défaut au moment du démarrage. Donc, ce logiciel consomme de l'énergie et des composants du matériel, bien qu'ils ne soient pas utilisés à la demende de l'utilisateur.

* *Mode Nuit / Jour :* ///reste à faire///

Ce critère a été défini par le questionnaire avec un pourcentage de 43.5%.

Ce critère signifie si le logiciel a le mode jour/ nuit. 

* *Optimiser l'utilisation du CPU :*

Ce critère a été défini après avoir obtenu un pourcentage de 39.1%  dans le questionnaire.

Ce critère indique le nombre d'accès au CPU. Plus le nombre d'accès au CPU est élevé, plus la consommation électrique est importante, et plus la durée de vie du CPU est courte.

* *Optimiser l'algorithmie ( Action humaine ) :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère signifie que si les développeurs ont amélioré des algorithmes déjà existantes, pour améliorer leurs performances en les rendant plus sobres. L'objectif est de diminuer l'utilisation des ressources matérielles et de la consommation d'énergie. Cela rend le logiciel plus Green.

* *Optimiser les instructions de code ( Action compilateur) :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère détermine si le compilateur, par son amélioration de l'algorithme sans besoin de l'intervention des developpeurs, rend la procédure d'exécution du logiciel est plus green.

Ce critère signifie que si le compilateur a amélioré l'algorithme sans l'intervention des développeurs.

* *Taux I/O RAM VS Disque Dur :* 

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère indique le nombre d’accès au RAM et au disque dur. Après avoir consulté l'avis des experts, il est apparent que le disque dur consomme plus d'énergie que le RAM, ce qui rend l'optimisation de l'utilisation du disque dur favorable en faveur de la protéction de l'environnement.

* *Optimiser l'utilisation de la Mémoire :*

Ce critère a été défini après avoir obtenu un pourcentage de 21.7%  dans le questionnaire. 

Ce critère insiste sur l'importance de la sobriété des algorithmes et de la manière dont le logiciel a été programmé, afin de préserver l'environnement. Plus les algorithmes et la manière de prgrammation sont simples et efficaces, moins le logiciel a besoin d'accès à la mémoire, et moins il cosomme de l'énergie.

* *Binaire qui prend de l'espace :* /// reste à faire ///

Ce critère a été difinie par l'interview <<Annexe?>>.

Si la conception ne se concentre pas uniquement sur les besoins, le logiciel sera obèse. Le dernier prendra donc beaucoup d'espace. Ainsi, le logiciel utilisera plus de ressources matérieles sans réel bénéfice de l'utilisateur. Cela rend l'appariel informatique obsolète plus vite. 

* *Pourcentage d'utilisation d'Open Source :*

Ce critère a été ajouté par ma propre expérience et approuvé par le questionnaire avec un pourcentage de 13%.

Ce critère signifie si le logiciel est développé en Open-source ou pas. Son avantage réside dans la capacité des utilisateurs à utiliser le logiciel sans être dépendants de l'éditeur et ses mises à jours. Ces mises à jours rendent souvent les anciens appareils informatiques obsolètes, ce qui nécessite d'en acheter des nouveaux. La capacité des utilisateurs à utiliser des logiciels d'Open-source, à les améliorer, et à les modifier, leur permet de prolonger la durée du vie de leurs appareils informatiques, et par conséquent de protéger l'environnement.

* *Bugs :*

Ce critère a été défini par le questionnaire avec un pourcentage de 20%.

Ce critère signifie si le logiciel comporte beaucoup de bugs, et s'il nécessite une maintenance régulière. Dans ce cas, le logiciel doit être mis à jour régulièrement. Ce dernier rend le logiciel plus obèse, donc plus obsolète. Cela a été bien clarifié selon le premier critère.

* *La mauvaise lisibilité du code pour mieux l’appréhender ( Évolution correction) :*

Suite à la réflexion au sujet de la "Durabilité des logiciels", ce critère est apparu utile à être join aux critères de durabilité selon ma propre expérience.

Ce critère signifie si le logiciel est bien développé, et si le code est bien écrit de manière claire. Cela facilite l'évolution par les développeurs et l'exécution par le compilateur.

.Matrice 
[caption="Figure 3: "]
image::Matrice.jpg[Matrice]


Impact fort sur l'utilisation de la batterie;TRILEAN;Utilisation; -> travail futur

Empriente résiduelle;POURCENTAGE;Intégration;  -> travail futur

=== 6.2.Cas Pratiques de la matrice

Afin de valider la bonne conception de la matrice, un cas pratique concernant le logiciel mobile "Éco2mix", développé par l'entreprise RTE, a été étudié. les lignes suivantes expliquent les tests effectués de ce cas pratique.

==== 6.2.1.Cas Pratique "Éco2mix"

J'ai fait une interview avec M. Nathaël GALANTE-GRAS, le chef de projet de l'application "Éco2mix". Cette application est accessible à tous, pas seulement aux clients de RTE ou ses agents. Elle est intégrée dans un autre site de RTE, appelé "RTE France". Éco2mix est opérable sur Android et IOS. 

Cette application est dédié à exposer les données de RTE sur les utilisations et la production d'énergie (prod nucléaire, solaire, hydraulique, photovoltaïque...) à la fois en France entier et au niveau des régions administratives et dans certaines métropoles. L'application donne aussi la consommation énergétique moyenne d'une maison en France et la possibilité de la comparer avec celles des individus pour objectif de mieux gérer le bilan énergétique. Les échanges effectués de tous les paramétres électriques au niveau des régions françaises, et celui entre la France avec ses pays voisins, on aussi étaient inclus dans cette application.

La discussion avec M. GALANTE-GRAS a conclu les résultats suivantes : 

* 1er critère a obtenu la valeur 0 - 20% : Éco2mix est souvent supporté par des mises à jour fonctionnelle, et n'est pas toujours supporté par des mises à jour sécurité. Éco2mix ne sépare pas les deux types de mises à jour, ce qui justifie la valeur attribuée. 

* Deuxième critère a obtenu la valeur 40 - 60% : Éco2mix interagit avec l'utilisateur en se basant sur des données déjà téléchargées avec le démarrage du logiciel. Puis, au fut et à mesure, Éco2mix télécharge les données nécessaires aux opérations effectuées par l'utilisateur.  

* Troisième critère a obtenu la valeur 60 - 80% : la programmation utilisée est la Programmation orientée Objet.

* Quatrième critère a obtenu la valeur 80 - 100% : le cloud ne fait pas partie des caractéristiques techniques d'Éco2mix, ce qui justifie la valeur attribuée.

* Cinquième critère a obtenu la valeur 50 - 60% : les données d'Éco2mix sont organisées à la fois en Fichiers et en Base de données.

* Sixième critère a obtenu la valeur 80 - 100% : Éco2mix stocke ses données localement, ce qui lui donne la bonne valeur.

* Septième critère a obtenu la valeur 20 - 40% : Éxo2mix fait beaucoup de requêtes avec le réseau, ce qui diminue la valeur attribuée.

* Huitième critère a obtenu la valeur 40 - 60% : Éco2mix est codé en Java (Compilé), PHP (interprété) et JavaScript (interprété). Alors, la valeur de ce critère a été choisi à 50%, placée dans l'intervalle : 40 - 60%.

* Neuvième critère a obtenu la valeur 60 - 80% : Éco2mix ne travaille pas en arrière plan, à l'exception de quelques processus tel que le processus de notification.

* Dixième critère a obtenu la valeur 20 - 40% : Éco2mix se lance automatiquement au démarrage, afin de réaliser quelques tâches. 

* Onzième critère a obtenu la valeur 0 - 20% : Éco2mix ne supporte pas la caractéristique du mode nuit / jour, ce qui dégrade la valeur de ce critère.

* Douzième critère a obtenu la valeur 60 - 80% : la valeur de ce critère a été attribuée grâce au fait que Éco2mix n'utilise pas énormément le CPU.

* Treizième critère a obtenu la valeur 80 - 100% : Éco2mix est un logiciel plutôt front, donc, la valeur a été attribuée car il n'a y pas beaucoup d'algorithèmes à optimiser.

* Quatorzième critère a obtenu la valeur 40 - 60% : 

* Quanzième critère a obtenu la valeur 60 - 80% : vu qu'Éco2mix est un logiciel mobile et web, il ne utilise pas le Disque Dur, et il n'occupe qu'une petite partie du RAM.

* Seizième critère a obtenu la valeur 60 - 80% : Éco2mix a obteun cette valeur grâce au fait qu'il n'utilise pas beaucoup la mémoire.

* Dix-septième critère a obtenu la valeur 80 - 100% : Éco2mix est un logiciel largement léger, ainsi son espace binaire est 50MO. 

* Dix-huitième critère a obtenu la valeur 0 - 20% : Éco2mix a obtenu cette valeur parce qu'il est déveloopé en closed-source.

* Dix-neuvième critère a obtenu la valeur 20 - 40% : Éco2mix subit souvent des Bugs.

* Vigntième critère a obtenu la valeur 40 - 60% : le code d'Éco2mix est un peu compliqué en quelques sorts.

.Matrice Éco2mix 
[caption="Figure 3: "]
image::Matrice-Eco2mix.jpg[Matrice Éco2mix ]

===== 6.2.1.2.Calcul de durabilité d'Éco2mix

La somme des valeurs de la catégorie de Conception : 20 + 60 + 80 + 100 + 60 + 100 + 40 + 60 + 80 + 40 + 20 = 660 

La note de la catégorie de Conception : 660 / 11 = 60%

Cela signifie que Éco2mix est classé dans la catégorie *Bien* avec la note 3 / 5 selon les classification de durabilité des logiciels établies dans ce mémoire.

La somme des valeurs de la catégorie de Développement : 80 + 100 + 60 + 80 + 80 + 100 + 20 + 40 + 60 = 620 

La note de la catégorie de Conception : 620 / 9 = 69%

Pour cette catégorie Éco2mix est classé dans la catégorie *Très Bien* avec la note 4 / 5 selon les classification de durabilité des logiciels établies dans ce mémoire.

===== 6.2.1.3.Observations et Conclusion /// reste à faire ///

En sa globalité, Éco2mix est un bon logiciel à la fois dans l'aspect de conception et dans l'aspect de développement. Il est conseillé, afin d'améliorer la durabilité d'Éco2mix, d'appliquer ces recommandations : 

* Il serait bien si Éco2mix fait la séparation entre les mises à jour de sécurité et les mises à jour fonctionnelles et informe le client de cette séparation lorsque les mises à jour sont installées. 
* Les développeurs ont tout l'intérêt de diminuer le nombre de requêtes avec le réseau, afin d'optimiser la performance environnementale d'Éco2mix.
* La performance énergétique d'Éco2mix est affecté par le manque d'avoir le mode nuit / jour, ainsi, il est apparu utile de traiter cette aspect afin d'améliorer la performance d'Éco2mix.
* 
