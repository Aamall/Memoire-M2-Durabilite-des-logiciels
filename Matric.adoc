:imagesdir: ./images
<<<

[#Matrice]
== 6.Les clés de la durabilité de logiciels (Matrice) /// rest à faire, vérifier le numéro d'annexe///

Après avoir recueilli les critères, j'ai dû les organiser en une matrice. Cette dernière illustre la durabilité du logiciel en lui donnant une note de 1 à 5.

Ces notes : 

* *1* -> 0 - 20% -> le logiciel est *Mauvais*. 
* *2* -> 20 - 40% -> le logiciel est *Moyen*.
* *3* -> 40 - 60% -> le logiciel est *Bien*.
* *4* -> 60 - 80% -> le logiciel est *Très bien*. 
* *5* -> 80 - 100% -> le logiciel est *Excellent*.

Pour réaliser cette matrice, je l'ai divisée en deux parties.  La première, à gauche, contient les critères utilisés. Ceux-ci sont classés en deux catégories : *Conception* et *Développement*, en ajoutant leur type et leur poids.
La deuxième, à droite, à remplir par *le chef de projet*.

Pour le type de critères, j'ai choisi trois types : 

* *Trilean* (True, False, Null).
* *Boolean* (True, False).
* *Pourcentage*. 

Pour le poids, j'ai donné à deux catégories (conception et développement) la valeur 100. Ensuite, pour chaque critère de ces catégories, j'ai donné une valeur de 100 pour l'importance du critère sur la base des interviews et du questionnaire.

Voici les critères retenus pour la matrice : 

* *Mise à jour de sécurité jointes aux mises à jour fonctionnelles :* 

Ce critère signifie que l'éditeur de logiciels doit être transparent pour séparer les mises à jour de sécurité des mises à jour fonctionnelles en annonçant au client le type de mise à jour auquel chaque mise à jour est destinée (mise à jour corrective, mise à jour évolutive). Car les mises à jour correctives sont indispensables et souvent légères. Au contraire, les mises à jour évolutives ne sont pas indispensables et lourdes.

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. En outre, ce critère avait le pourcentage de 52,2% dans le questionnaire.

* *Lazy loading :*

Ce critère signifie que le logiciel doit télécharger ses dépendances lorsqu'il en a besoin.  Cela signifie que le logiciel ne consomme de l'énergie et de l'appel réseau concernant ces dépendances que lorsqu'il est nécessaire, ce qui reflète l'évaluation du Green de ce critère.

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*.

*Lazy loading* : est un modèle de conception généralement utilisé en programmation informatique. Son objectif est d'initialiser un objet uniquement quand cet objet devient nécessaire. De cette manière, Lazy Loading participe effectivement à l'efficacité du fonctionnement du logiciel s'il est utilisé d'une façon correcte et adéquate. Cela rend Lazy Loading une propriété idéale dans les cas d’utilisation où le contenu du réseau est accessible et où le temps d’initialisation doit être réduit au minimum, comme dans le cas des pages web. L’inverse de Lazy Loading est Eager Loading. <<R>>

* *Programmation Objet vs Programmation Fonctionnelle :*

Ce critère a été défini par l'interview <<Annexe?>>. 

*Programmation Objet*: est un modèle de programmation informatique étant formé de la définition et l'interaction de blocs logiciels appelés objets. Ces derniers représentent plusieurs variables pouvant aller des concepts et des idées à toute entité du monde physique, comme un ordinateur, une maison, etc. Ces objets possèdent une structure interne et un comportement, et savent interagir avec leurs pairs. L'objectif de la Programmation Orientée Objet est de représenter ces objets et leurs relations pour mieux résoudre le problème ; cela peut être effecteur en concevant et en réalisant les fonctionnalités attendues par l'interaction entre les objets via leurs relations. De ce qui précède, l'étape de modélisation évoque une grande importance nécessaire pour la Programmation Orientée Objet, puisque la transcription des réels éléments sous forme virtuelle se passe durant cette étape. <<S>>

*Programmation Fonctionnelle* :  est un modèle de programmation de type déclaratif et se concentre sur la notion des fonctions. Le calcul est considéré comme une évaluation des fonctions mathématiques dans ce modèle, ce qui veut dire que tous les éléments sont définies comme des fonctions et le code s'exécute par des appels successifs des fonctions . <<T>>

* *Cloud Synchronisation :* 

Le cloud se définit par la mise en disposition des ressources informatiques utilisables depuis toutes les types terminales via l'internet. 

D'après ma propre expérience, ce critère a été ajouté suite à la pose de la question : *Est-ce le cloud est green?*


Comme mentionné dans l'état de l'art, (page à ajouter), les terminaux que nous utilisons génèrent des impacts environnementaux et sociaux très importants, non seulement en termes de fabrication, mais aussi en termes d'utilisation et de fin de vie. Sachant que les entreprises utilisent le cloud pour stocker leurs données et permettre à leurs employeurs de travailler à distance.  Cela nécessite donc une forte augmentation des besoins en matériel pour sauvegarder les données, généralement accompagnée d'attentes élevées en termes de sécurité, ce qui se traduit par une infrastructure physique surdimensionnée. De plus, les déploiements de sécurité des données, l'illusion d'une capacité infinie, encourage l'informatique débridée *l'obésité*.

Toutefois, il existe sans aucun doute une utilisation éclairée du cloud !

Il existe sur l'internet une vidéo réalisée par l'Alliance Green IT, illustre que le Cloud n’est pas la panacée à la problématique environnementale du stockage et l’utilisation de données numériques. Disponible sur : https://www.dailymotion.com/video/x2hntue

* *Fichier VS Base De Données :*

Ce critère a été défini par l'interview <<Annexe?>>.


* *Stockage Réseau VS Local :*

Ce critère a été défini par l'interview <<Annexe?>>.

Ce critère désigne quel type de stockage est utilisé. 
Le stockage en réseau nécessite un réseau pour stocker les donnéesdans les centres de données. Le fonctionnement de ces derniers nécessite d'énergie et du refroidissement constants, ce qui augmente l'impact environnemental négatif. Le stockage local stocke les données directement en mémoire, et donc il n'utilise qu'une part de l'énergie nécessaire au fonctionnement de l'appareil informatique. Ce dernier peut être éteint ce qui diminue l'impact environnemental négatif. 

* *Appel Réseau :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère indique le nombre de demandes que le logiciel a présenté. Plus le nombre de demandes est élevé, plus l'impact du logiciel sur l'environnement à travers le matériel et le réseau est important.

* *Compilé VS Interprété :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère indique le type utilisé du langage de programmation : Compilé ou Interprété.

À partir de la définition de chaque langage, le langage compilé est plus rapide et traduit le code directement en langage machine. Alors que le langage interprété a besoin d'un interprète, ce qui complique la procédure et consomme plus d'énergie. De ce qui précède, le langage compilé est plus favorable en faveur des exigences environnementales.

* *Travail en arrière paln :* 

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*.

Ce critère indique si le logiciel contient des composants qui fonctionnent en arrière paln, c'est-à-dire si le logiciel fonctionne lorsqu'il n'est pas utilisé par l'utilisateur. En effet, un tel logiciel consomme de l'énergie, même s'il est dans un cas inactif. Ce qui annonce que ce critère rend le logiciel moins Green.

* *Lancer automatiquement au démarrage par défaut :*

Ce critère a été défini par le questionnaire avec un pourcentage de 39.1%.

Ce critère signifie que les dépendances de logiciel fonctionnent directement par défaut au moment du démarrage. Car ce logiciel consomme l'énergie et les composants du matériel, bien qu'ils ne soient pas utilisés à la demende de l'utilisateur.

* *Mode Nuit / Jour :* ///reste à faire///

Ce critère a été défini par le questionnaire avec un pourcentage de 43.5%.

Ce critère signifie si le logiciel a le mode jour/ nuit. 

* *Optimiser l'utilisation du CPU (Usage intensif du CPU) :*

Ce critère a été défini par le questionnaire sous le thème "Utilisation intensive du CPU". Je l'ai modifié pour mettre tous les critères en cas positif dans ma matrice.

Ce critère signifie le nombre d'accès au CPU. Plus le nombre d'accès est faible, moins la consommation électrique est importante, plus la consommation de l'unité centrale est faible.

* *Optimiser l'algorithmie ( Action humaine ) :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère signifie que si les développeurs ont amélioré des algorithmes déjà existants pour améliorer leurs performances.

* *Optimiser les instructions de code ( Action compilateur) :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère signifie que le compilateur a amélioré l'algorithme sans l'intervention des développeurs.

* *Taux I/O RAM VS Disque Dur :* /// reste à faire///

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère signifie le nombre d'accès à la mémoire vive et au disque dur.

* *Optimiser l'utilisation du Mémoire ( Usage intensif du Mémoire) :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère a été défini par le questionnaire sous le thème "Utilisation intensive du Mémoire". Je l'ai modifié pour mettre tous les critères en cas positif dans ma matrice.

Ce critère signifie le nombre d'accès à la mémoire. Plus le nombre d'accès est faible, moins la consommation électrique est importante, plus la consommation de la mémoire est faible.

* *Binaire qui prend de l'espace :* /// reste à faire ///

Ce critère à été identifié dans l'état de l'art (page à ajouter). 

Si la conception ne se concentre pas uniquement sur les besoins, le logiciel sera obèse. Le dernier prendra donc beaucoup de place.
Comme le montre l'état de l'art, plus un logiciel devient obèse, plus il sera obsolète.

* *Pourcentage d'utilisation d'Open Source :* /// reste à faire ///

Ce critère a été défini par le questionnaire.

Ce critère signifie que si le logiciel est développé en Open-source. Car dans le développement en Open-source, l'utilisateur peut accéder au code pour le modifier, l'améliorer, en ce qui correspond à ses besoins. 

L'Open-source est utile dans le cas où l'éditeur ne prend plus en charge le logiciel. Parce que l'utilisateur peut faire la maintenance en cas de bogues de sécurité. 

* *Bugs :*

Ce critère a été défini par le questionnaire.

Ce critère signifie que si le logiciel comporte beaucoup de bogues. Et s'il nécessite une maintenance régulière. Car dans ce cas, le logiciel doit être mis à jour régulièrement. Ce dernier rend le logiciel plus obèse, donc plus obsolète. C'est ce que signifie le premier critère.

* *La mauvaise lisibilité du code pour mieux l'appréhendre ( Évolution correction) :*

Ce critère a été défini par le questionnaire.

Ce critère signifie que le logiciel est bien développé, et que le code est bien écrit de manière claire pour être lu et compris afin d'en faciliter l'évolution.

.Matrice 
[caption="Figure 3: "]
image::Matrice.jpg[Matrice]


Impact fort sur l'utilisation de la batterie;TRILEAN;Utilisation; -> travail futur

Empriente résiduelle;POURCENTAGE;Intégration;  -> travail futur
