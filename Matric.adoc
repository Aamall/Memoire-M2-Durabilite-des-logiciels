:imagesdir: ./images
<<<

== 5.Les clés de la durabilité de logiciels (Matrice) /// rest à faire///

Après avoir recueilli les critères, j'ai dû les organiser en une matrice. Cette dernière illustre la durabilité du logiciel en lui donnant une note de 1 à 5.

Ces notes : 

* *1* -> 20% -> le logiciel est *Mauvais*. 
* *2* -> 40% -> le logiciel est *Moyen*.
* *3* -> 60% -> le logiciel est *Bien*.
* *4* -> 80% -> le logiciel est *Très bien*. 
* *5* -> 100% -> le logiciel est *Excellent*.

Pour réaliser cette matrice, je l'ai divisée en deux parties.  La première, à gauche, contient les critères utilisés. Ceux-ci sont classés en deux catégories : *Conception* et *Développement*, en ajoutant leur type et leur poids.
La deuxième, à droite, à remplir par *le client*,  ???*le chef de projet*.



Voici les critères retenus pour la matrice : 

* Mise à jour de sécurité jointes aux mises à jour fonctionnelles : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Lazy loading : 

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. ?

*Lazy loading* :  est un modèle de conception couramment utilisé en programmation informatique pour différer l'initialisation d'un objet jusqu'au moment où il est nécessaire. Il peut contribuer à l'efficacité du fonctionnement du programme s'il est utilisé correctement et convenablement. Il est donc idéal dans les cas d'utilisation où le contenu du réseau est accessible et où les temps d'initialisation doivent être réduits au minimum, comme dans le cas des pages web. L'inverse de lazy loading is eager loading. <<R>>

* Programmation Objet vs Programmation Fonctionnelle : 

Ce critère a été défini par l'interview <<Annexe?>>. 

*Programmation Objet*: est un paradigme de programmation informatique. Il consiste en la définition et l'interaction de briques logicielles appelées objets ; un objet représente un concept, une idée ou toute entité du monde physique, comme une voiture, une personne ou encore une page d'un livre. Il possède une structure interne et un comportement, et il sait interagir avec ses pairs. Il s'agit donc de représenter ces objets et leurs relations ; l'interaction entre les objets via leurs relations permet de concevoir et réaliser les fonctionnalités attendues, de mieux résoudre le ou les problèmes. Dès lors, l'étape de modélisation revêt une importance majeure et nécessaire pour la POO. C'est elle qui permet de transcrire les éléments du réel sous forme virtuelle. <<S>>

*Programmation Fonctionnelle* :  est un paradigme de programmation de type déclaratif qui considère le calcul en tant qu'évaluation de fonctions mathématiques. <<T>>

* Cloud Synchronisation : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Fichier VS Base De Données : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Stockage Réseau VS Local : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Appel Réseau : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Compilé VS Interpreté : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Travaille en arrière paln : 

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. ?

* Lancer automatiquement au démarrage par défaut :

Ce critère a été défini par l'interview <<Annexe?>>. 

* Mode Nuit / Jour : 

Ce critère a été défini par le questionnaire.

* Optimiser l'utilisation du CPU (Usage intensif du CPU) : 

Ce critère a été défini par le questionnaire.

* Optimiser l'algorithmie ( Action humaine ) : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Optimiser les instructions de code ( Action compilateur) : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Taux I/O RAM VS DD : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Optimiser l'utilisation du Mémoire ( Usage intensif du Mémoire) : 

Ce critère a été défini par l'interview <<Annexe?>>. 

* Binaire qui prend de l'espace : 

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. ?

* Pourcentage d'utilisation d'Open Source : 

Ce critère a été défini par le questionnaire.

* Bugs : 

Ce critère a été défini par le questionnaire.

* La mauvaise lisibilité du code pour mieux l'appréhendre ( Évolution correction) : 

Ce critère a été défini par le questionnaire.


.Matrice 
[caption="Figure 3: "]
image::Matrice.jpg[Matrice]


Impact fort sur l'utilisation de la batterie;TRILEAN;Utilisation; -> travail futur

Empriente résiduelle;POURCENTAGE;Intégration;  -> travail futur
