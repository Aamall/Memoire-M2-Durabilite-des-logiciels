:imagesdir: ./images
<<<

[#Matrice]
== 6.Les clés de la durabilité de logiciels (Matrice) /// rest à faire, vérifier le numéro d'annexe///

Après avoir recueilli les critères, j'ai dû les organiser en une matrice. Cette dernière illustre la durabilité du logiciel en lui donnant une note de 1 à 5.

Ces notes : 

* *1* -> 0 - 20% -> le logiciel est *Mauvais*. 
* *2* -> 20 - 40% -> le logiciel est *Moyen*.
* *3* -> 40 - 60% -> le logiciel est *Bien*.
* *4* -> 60 - 80% -> le logiciel est *Très bien*. 
* *5* -> 80 - 100% -> le logiciel est *Excellent*.

Pour réaliser cette matrice, je l'ai divisée en deux parties.  La première, à gauche, contient les critères utilisés. Ceux-ci sont classés en deux catégories : *Conception* et *Développement*, en ajoutant leur type et leur poids.
La deuxième, à droite, à remplir par *le chef de projet*.

Pour le type de critères, j'ai choisi trois types : 

* *Trilean* (True, False, Null).
* *Boolean* (True, False).
* *Pourcentage*. 

Pour le poids, j'ai donné la valeur 100 à deux catégories (conception et développement). Ensuite, pour chaque critère de ces catégories, j'ai donné une valeur sur 100 selon l'importance du critère établi sur la base des interviews et du questionnaire.

=== 6.1.Les critères retenus pour la matrice  

* *Mise à jour de sécurité jointes aux mises à jour fonctionnelles :* 

Ce critère signifie que l'éditeur de logiciels doit être transparent pour séparer les mises à jour de sécurité des mises à jour fonctionnelles en annonçant au client le type de mise à jour auquel chaque mise à jour est destinée (mise à jour corrective, mise à jour évolutive). Car les mises à jour correctives sont indispensables et souvent légères. Au contraire, les mises à jour évolutives ne sont pas indispensables et lourdes.

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*. En outre, ce critère avait le pourcentage de 52,2% dans le questionnaire.

* *Lazy loading :*

Ce critère signifie que le logiciel doit télécharger ses dépendances lorsqu'il en a besoin. Cela signifie que le logiciel ne consomme de l'énergie et de l'appel réseau concernant ces dépendances que lorsqu'il est nécessaire, ce qui reflète l'évaluation du Green de ce critère.

Ce critère est parmi ceux ajoutés selon ma propre expérience en ce qui concerne le sujet de *Durabilité des logiciels*.

*Lazy loading* : est un modèle de conception généralement utilisé en programmation informatique. Son objectif est d'initialiser un objet uniquement quand cet objet devient nécessaire. De cette manière, Lazy Loading participe effectivement à l'efficacité du fonctionnement du logiciel s'il est utilisé d'une façon correcte et adéquate. Cela rend Lazy Loading une propriété idéale dans les cas d’utilisation où le contenu du réseau est accessible et où le temps d’initialisation doit être réduit au minimum, comme dans le cas des pages web. L’inverse de Lazy Loading est Eager Loading. <<R>>

* *Programmation Orienté Objet vs Programmation Fonctionnelle :*

Ce critère a été défini par l'interview <<Annexe?>>. Selon l'avis des experts, la programmation orientée objet est plus légère et rapide que la programmation fonctionnelle. Puisqu'elle ne utilise que les objets nécessaires à réaliser les fonctionnalitiés attendues. Ce qui limite l'utilisation des ressources matériels au minimum. Par conséquent, la programmation orientée objet est plus préservante de l'environnement.

*Programmation orientée Objet*: est un modèle de programmation informatique étant formé de la définition et l'interaction de blocs logiciels appelés objets. Ces derniers représentent plusieurs variables pouvant aller des concepts et des idées à toute entité du monde physique, comme un ordinateur, une maison, etc. Ces objets possèdent une structure interne et un comportement, et savent interagir avec leurs pairs. L'objectif de la Programmation Orientée Objet est de représenter ces objets et leurs relations pour mieux résoudre le problème ; cela peut être effecteur en concevant et en réalisant les fonctionnalités attendues par l'interaction entre les objets via leurs relations. De ce qui précède, l'étape de modélisation évoque une grande importance nécessaire pour la Programmation Orientée Objet, puisque la transcription des réels éléments sous forme virtuelle se passe durant cette étape. <<S>>

*Programmation Fonctionnelle* :  est un modèle de programmation de type déclaratif et se concentre sur la notion des fonctions. Le calcul est considéré comme une évaluation des fonctions mathématiques dans ce modèle, ce qui veut dire que tous les éléments sont définies comme des fonctions et le code s'exécute par des appels successifs des fonctions . <<T>>

* *Cloud Synchronisation :* 

Le cloud se définit par la mise en disposition des ressources informatiques utilisables depuis toutes les types terminales via l'internet. 

D'après ma propre expérience, ce critère a été ajouté suite à la pose de la question : *Est-ce le cloud est green?*


Comme mentionné dans l'état de l'art, (page à ajouter), les terminaux que nous utilisons génèrent des impacts environnementaux et sociaux très importants, non seulement en termes de fabrication, mais aussi en termes d'utilisation et de fin de vie. Sachant que les entreprises utilisent le cloud pour stocker leurs données et permettre à leurs employeurs de travailler à distance.  Cela nécessite donc une forte augmentation des besoins en matériel pour sauvegarder les données, généralement accompagnée d'attentes élevées en termes de sécurité, ce qui se traduit par une infrastructure physique surdimensionnée. De plus, les déploiements de sécurité des données, l'illusion d'une capacité infinie, encourage l'informatique débridée *obèse*.

Toutefois, il existe sans aucun doute une utilisation éclairée du cloud !

Il existe sur l'internet une vidéo réalisée par l'Alliance Green IT, illustre que le Cloud n’est pas la panacée à la problématique environnementale du stockage et l’utilisation de données numériques. Disponible sur : https://www.dailymotion.com/video/x2hntue

* *Fichier VS Base De Données :*

Ce critère a été défini par l'interview <<Annexe?>>. 

La structure logicielle du fichier est simple est sobre. Par contre, la structure logicielle de la base de donnée est plus compliquée et costaude. Ainsi, et afin de moins utiliser de l'énergie au but de préserver l'environnement, la structure logicielle de la base de donnée doit être simple et organisée de manière facilitante les requêtes.


* *Stockage Réseau VS Local :*

Ce critère a été défini par l'interview <<Annexe?>>.

Ce critère désigne quel type de stockage est utilisé. 
Le stockage en réseau nécessite un réseau pour stocker les données dans les centres de données. Le fonctionnement de ces derniers nécessite de l'énergie et du refroidissement constants, ce qui augmente l'impact environnemental négatif. Le stockage local stocke les données directement en mémoire, et donc il n'utilise qu'une part de l'énergie nécessaire au fonctionnement de l'appareil informatique. Ce dernier peut être éteint ce qui diminue l'impact environnemental négatif. 

* *Appel Réseau :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère indique le nombre de demandes que le logiciel a présenté. Plus le nombre de demandes est élevé, plus l'impact du logiciel sur l'environnement à travers le matériel et le réseau est important.

* *Compilé VS Interprété :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère indique le type utilisé du langage de programmation : Compilé ou Interprété.

À partir de la définition de chaque langage, le langage compilé est plus rapide et traduit le code directement en langage machine. Alors que le langage interprété a besoin d'un interprète, ce qui complique la procédure et consomme plus d'énergie. De ce qui précède, le langage compilé est plus favorable en faveur des exigences environnementales.

* *Travail en arrière paln :* 

Ce critère a été ajouté selon ma propre expérience, suite à la réflexion que j'ai menée au sujet de *Durabilité des logiciels*.

Ce critère indique si le logiciel contient des composants qui fonctionnent en arrière paln, c'est-à-dire si le logiciel fonctionne lorsqu'il n'est pas utilisé par l'utilisateur. En effet, un tel logiciel consomme de l'énergie, même s'il est dans un cas inactif. Ce qui annonce que ce critère rend le logiciel moins Green.

* *Lancer automatiquement au démarrage par défaut :*

Ce critère a été défini par le questionnaire avec un pourcentage de 39.1%.

Ce critère signifie que les dépendances de logiciel fonctionnent directement par défaut au moment du démarrage. Donc, ce logiciel consomme de l'énergie et des composants du matériel, bien qu'ils ne soient pas utilisés à la demende de l'utilisateur.

* *Mode Nuit / Jour :* ///reste à faire///

Ce critère a été défini par le questionnaire avec un pourcentage de 43.5%.

Ce critère signifie si le logiciel a le mode jour/ nuit. 

* *Optimiser l'utilisation du CPU :*

Ce critère a été défini après avoir obtenu un pourcentage de 39.1%  dans le questionnaire.

Ce critère indique le nombre d'accès au CPU. Plus le nombre d'accès au CPU est élevé, plus la consommation électrique est importante, et plus la durée de vie du CPU est courte.

* *Optimiser l'algorithmie ( Action humaine ) :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère signifie que si les développeurs ont amélioré des algorithmes déjà existantes, pour améliorer leurs performances en les rendant plus sobres. L'objectif est de diminuer l'utilisation des ressources matérielles et de la consommation d'énergie. Cela rend le logiciel plus Green.

* *Optimiser les instructions de code ( Action compilateur) :*

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère détermine si le compilateur, par son amélioration de l'algorithme sans besoin de l'intervention des developpeurs, rend la procédure d'exécution du logiciel est plus green.

Ce critère signifie que si le compilateur a amélioré l'algorithme sans l'intervention des développeurs.

* *Taux I/O RAM VS Disque Dur :* 

Ce critère a été défini par l'interview <<Annexe?>>. 

Ce critère indique le nombre d’accès au RAM et au disque dur. Après avoir consulté l'avis des experts, il est apparent que le disque dur consomme plus d'énergie que le RAM, ce qui rend l'optimisation de l'utilisation du disque dur favorable en faveur de la protéction de l'environnement.

* *Optimiser l'utilisation de la Mémoire :*

Ce critère a été défini après avoir obtenu un pourcentage de 21.7%  dans le questionnaire. 

Ce critère insiste sur l'importance de la sobriété des algorithmes et de la manière dont le logiciel a été programmé, afin de préserver l'environnement. Plus les algorithmes et la manière de prgrammation sont simples et efficaces, moins le logiciel a besoin d'accès à la mémoire, et moins il cosomme de l'énergie.

* *Binaire qui prend de l'espace :* /// reste à faire ///

Ce critère a été difinie par l'interview <<Annexe?>>.

Si la conception ne se concentre pas uniquement sur les besoins, le logiciel sera obèse. Le dernier prendra donc beaucoup d'espace. Ainsi, le logiciel utilisera plus de ressources matérieles sans réel bénéfice de l'utilisateur. Cela rend l'appariel informatique obsolète plus vite. 

* *Pourcentage d'utilisation d'Open Source :*

Ce critère a été ajouté par ma propre expérience et approuvé par le questionnaire avec un pourcentage de 13%.

Ce critère signifie si le logiciel est développé en Open-source ou pas. Son avantage réside dans la capacité des utilisateurs à utiliser le logiciel sans être dépendants de l'éditeur et ses mises à jours. Ces mises à jours rendent souvent les anciens appareils informatiques obsolètes, ce qui nécessite d'en acheter des nouveaux. La capacité des utilisateurs à utiliser des logiciels d'Open-source, à les améliorer, et à les modifier, leur permet de prolonger la durée du vie de leurs appareils informatiques, et par conséquent de protéger l'environnement.

* *Bugs :*

Ce critère a été défini par le questionnaire avec un pourcentage de 20%.

Ce critère signifie si le logiciel comporte beaucoup de bugs, et s'il nécessite une maintenance régulière. Dans ce cas, le logiciel doit être mis à jour régulièrement. Ce dernier rend le logiciel plus obèse, donc plus obsolète. Cela a été bien clarifié selon le premier critère.

* *La mauvaise lisibilité du code pour mieux l'appréhendre ( Évolution correction) :*

Suite à la réflexion au sujet de la "Durabilité des logiciels", ce critère est apparu utile à être join aux critères de durabilité selon ma propre expérience.

Ce critère signifie si le logiciel est bien développé, et si le code est bien écrit de manière claire. Cela facilite l'évolution par les développeurs et l'exécution par le compilateur.

.Matrice 
[caption="Figure 3: "]
image::Matrice.jpg[Matrice]


Impact fort sur l'utilisation de la batterie;TRILEAN;Utilisation; -> travail futur

Empriente résiduelle;POURCENTAGE;Intégration;  -> travail futur

=== 6.2.Cas Pratiques de la matrice

Afin de valider la bonne conception de la matrice, deux cas pratiques concernants deux logiciels mobile (Eco2mix et My window), développés par l'entreprise RTE, ont été étudiés. les lignes suivantes expliquent les tests effectués de ces cas pratiques.

==== 6.2.1.Cas Pratique "Éco2mix"

J'ai fait une interview avec M. Nathaël GALANTE-GRAS, le chef de projet de l'application "Éco2mix". Cette application est accessible à tous, pas seulement aux clients de RTE ou ses agents. Elle est intégrée dans un autre site de RTE, appelé "RTE France". Éco2mix est opérable sur Android et IOS. 

Cette application est dédié à exposer les données de RTE sur les utilisations et la production d'énergie (prod nucléaire, solaire, hydraulique, photovoltaïque...) à la fois en France entier et au niveau des régions administratives et dans certaines métropoles. L'application donne aussi la consommation énergétique moyenne d'une maison en France et la possibilité de la comparer avec celles des individus pour objectif de mieux gérer le bilan énergétique. Les échanges effectués de tous les paramétres électriques au niveau des régions françaises, et celui entre la France avec ses pays voisins, on aussi étaient inclus dans cette application.

La discussion avec M. GALANTE-GRAS a conclu les résultats suivantes : 

* Premier critère a obtenu la note 60 - 80% : Éco2mix est souvent supporté par des mises à jour fonctionnelle, et n'est pas toujours supporté par des mises à jour sécurité. Ce qui justifie la note attribuée concernant la séparation entre ces deux types  mais il n'a y pas de séperation entre les mises à jour fonctionnelle et les mises à jour sécurité, pour cela la note pour le premier critère était : 

2. Lazy loading 40 - 60%.

3. L'application Éco2mix est développé en Java, PHP et JavaScript. Donc, l'application est codé en Programmation orientée Objet. Cela donne au deuxième critère la note : 60 - 80%.

4. L'application Éco2mix n'utilise pas du tout le cloud. Alors, la note pour ce critère est : 100%.

5. Pour stocker les données, l'application Éco2mix sauvegarde ses données en Fichiers et en la Base de données. Donc, la note de ce critère est : 50 -60%.

6. L'application Éco2mix utilise le Stockage Local pour ses données. Pour cela, la note est : 80 - 100%.

7. Appel réseau, il y a pas mal des requêtes. Sa note est : 20 - 40%.

8. L'application Éco2mix est codé en Java (Compilé), PHP (interprété) et JavaScript (interprété). Alors, la note de ce critère est : 40 - 60%.

9. L'application Éco2mix ne travail pas en arrière paln. Donc, la note dans la matrice est : 100%.

10. L'application Éco2mix a des processus qui lancent automatiquement au démarrage. Donc, la note est : 20 - 40%.

11. L'application Éco2mix n'a pas le mode nuit/jour. Alors, sa note est : 0 - 20%.

12. L'application Éco2mix n'utilise pas énormément le CPU. Alors, la note de ce critère est : 20 - 40%.

13. L'application Éco2mix est une application fronte, donc, il n'a y pas beaucoup d'algorithèmes à optimiser. La note est : 80 - 100%.

14. L'application Éco2mix a la note 20 - 40% pour l'optimiser le code.

15. L'application Éco2mix est une application mobile et web. Donc, il ne utilise pas le RAM et le Disque Dur. Alors, la note est : 80 - 100%.

16. L'application Éco2mix a la note 20 - 40% pour l'optimiser l'utilisation du Mémoire. 

17. L'application Éco2mix prend l'espace 50MO, alors elle ne prend pas beaucoup d'espace. Pour cela, sa note est : 60 - 80%. 

18. L'application Éco2mix est déveloopé en closed-source. Sa note est : 0 - 20%.

19. L'application Éco2mix des Bugs. Sa note est : 50 - 60%.

20. Pour La mauvaise lisibilité du code pour mieux l'appréhender (évolutions, corrections), l'application Éco2mix a la note : 20 - 40%. 

.Matrice Éco2mix 
[caption="Figure 3: "]
image::Matrice-Eco2mix.jpg[Matrice Éco2mix ]

